<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="/web/tools/_project.yaml" />
  <meta name="book_path" value="/web/tools/_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: workbox-core/_private/DBWrapper.mjs</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: workbox-core/_private/DBWrapper.mjs</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/*
  Copyright 2017 Google Inc.

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

import &#x27;../_version.mjs&#x27;;

/**
 * A class that wraps common IndexedDB functionality in a promise-based API.
 * It exposes all the underlying power and functionality of IndexedDB, but
 * wraps the most commonly used features in a way that&#x27;s much simpler to use.
 *
 * @private
 */
class DBWrapper {
  /**
   * @param {string} name
   * @param {number} version
   * @param {Object&#x3D;} [callback]
   * @param {function(this:DBWrapper, Event)} [callbacks.onupgradeneeded]
   * @param {function(this:DBWrapper, Event)} [callbacks.onversionchange]
   *     Defaults to DBWrapper.prototype._onversionchange when not specified.
   */
  constructor(name, version, {
    onupgradeneeded,
    onversionchange &#x3D; this._onversionchange,
  } &#x3D; {}) {
    this._name &#x3D; name;
    this._version &#x3D; version;
    this._onupgradeneeded &#x3D; onupgradeneeded;
    this._onversionchange &#x3D; onversionchange;

    // If this is null, it means the database isn&#x27;t open.
    this._db &#x3D; null;
  }

  /**
   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded
   * callback, and added an onversionchange callback to the database.
   *
   * @return {IDBDatabase}
   */
  async open() {
    if (this._db) return;

    this._db &#x3D; await new Promise((resolve, reject) &#x3D;&gt; {
      // This flag is flipped to true if the timeout callback runs prior
      // to the request failing or succeeding. Note: we use a timeout instead
      // of an onblocked handler since there are cases where onblocked will
      // never never run. A timeout better handles all possible scenarios:
      // https://github.com/w3c/IndexedDB/issues/223
      let openRequestTimedOut &#x3D; false;
      setTimeout(() &#x3D;&gt; {
        openRequestTimedOut &#x3D; true;
        reject(new Error(&#x27;The open request was blocked and timed out&#x27;));
      }, this.OPEN_TIMEOUT);

      const openRequest &#x3D; indexedDB.open(this._name, this._version);
      openRequest.onerror &#x3D; (evt) &#x3D;&gt; reject(openRequest.error);
      openRequest.onupgradeneeded &#x3D; (evt) &#x3D;&gt; {
        if (openRequestTimedOut) {
          openRequest.transaction.abort();
          evt.target.result.close();
        } else if (this._onupgradeneeded) {
          this._onupgradeneeded(evt);
        }
      };
      openRequest.onsuccess &#x3D; (evt) &#x3D;&gt; {
        const db &#x3D; evt.target.result;
        if (openRequestTimedOut) {
          db.close();
        } else {
          db.onversionchange &#x3D; this._onversionchange;
          resolve(db);
        }
      };
    });

    return this;
  }

  /**
   * Delegates to the native &#x60;get()&#x60; method for the object store.
   *
   * @param {string} storeName The name of the object store to put the value.
   * @param {...*} args The values passed to the delegated method.
   * @return {*} The key of the entry.
   */
  async get(storeName, ...args) {
    return await this._call(&#x27;get&#x27;, storeName, &#x27;readonly&#x27;, ...args);
  }

  /**
   * Delegates to the native &#x60;add()&#x60; method for the object store.
   *
   * @param {string} storeName The name of the object store to put the value.
   * @param {...*} args The values passed to the delegated method.
   * @return {*} The key of the entry.
   */
  async add(storeName, ...args) {
    return await this._call(&#x27;add&#x27;, storeName, &#x27;readwrite&#x27;, ...args);
  }

  /**
   * Delegates to the native &#x60;put()&#x60; method for the object store.
   *
   * @param {string} storeName The name of the object store to put the value.
   * @param {...*} args The values passed to the delegated method.
   * @return {*} The key of the entry.
   */
  async put(storeName, ...args) {
    return await this._call(&#x27;put&#x27;, storeName, &#x27;readwrite&#x27;, ...args);
  }

  /**
   * Delegates to the native &#x60;delete()&#x60; method for the object store.
   *
   * @param {string} storeName
   * @param {...*} args The values passed to the delegated method.
   */
  async delete(storeName, ...args) {
    await this._call(&#x27;delete&#x27;, storeName, &#x27;readwrite&#x27;, ...args);
  }

  /**
   * Delegates to the native &#x60;getAll()&#x60; or polyfills it via the &#x60;find()&#x60;
   * method in older browsers.
   *
   * @param {string} storeName
   * @param {*} query
   * @param {number} count
   * @return {Array}
   */
  async getAll(storeName, query, count) {
    if (&#x27;getAll&#x27; in IDBObjectStore.prototype) {
      return await this._call(&#x27;getAll&#x27;, storeName, &#x27;readonly&#x27;, query, count);
    } else {
      return await this.getAllMatching(storeName, {query, count});
    }
  }

  /**
   * Supports flexible lookup in an object store by specifying an index,
   * query, direction, and count. This method returns an array of objects
   * with the signature .
   *
   * @param {string} storeName
   * @param {Object} [opts]
   * @param {IDBCursorDirection} [opts.direction]
   * @param {*} [opts.query]
   * @param {string} [opts.index] The index to use (if specified).
   * @param {number} [opts.count] The max number of results to return.
   * @param {boolean} [opts.includeKeys] When true, the structure of the
   *     returned objects is changed from an array of values to an array of
   *     objects in the form {key, primaryKey, value}.
   * @return {Array}
   */
  async getAllMatching(storeName, opts &#x3D; {}) {
    return await this.transaction([storeName], &#x27;readonly&#x27;, (stores, done) &#x3D;&gt; {
      const store &#x3D; stores[storeName];
      const target &#x3D; opts.index ? store.index(opts.index) : store;
      const results &#x3D; [];

      target.openCursor(opts.query, opts.direction).onsuccess &#x3D; (evt) &#x3D;&gt; {
        const cursor &#x3D; evt.target.result;
        if (cursor) {
          const {primaryKey, key, value} &#x3D; cursor;
          results.push(opts.includeKeys ? {primaryKey, key, value} : value);
          if (opts.count &amp;amp;&amp;amp; results.length &gt;&#x3D; opts.count) {
            done(results);
          } else {
            cursor.continue();
          }
        } else {
          done(results);
        }
      };
    });
  }

  /**
   * Accepts a list of stores, a transaction type, and a callback and
   * performs a transaction. A promise is returned that resolves to whatever
   * value the callback chooses. The callback holds all the transaction logic
   * and is invoked with three arguments:
   *   1. An object mapping object store names to IDBObjectStore values.
   *   2. A &#x60;done&#x60; function, that&#x27;s used to resolve the promise when
   *      when the transaction is done.
   *   3. An &#x60;abort&#x60; function that can be called to abort the transaction
   *      at any time.
   *
   * @param {Array&amp;lt;string&gt;} storeNames An array of object store names
   *     involved in the transaction.
   * @param {string} type Can be &#x60;readonly&#x60; or &#x60;readwrite&#x60;.
   * @param {function(Object, function(), function(*)):?IDBRequest} callback
   * @return {*} The result of the transaction ran by the callback.
   */
  async transaction(storeNames, type, callback) {
    await this.open();
    const result &#x3D; await new Promise((resolve, reject) &#x3D;&gt; {
      const txn &#x3D; this._db.transaction(storeNames, type);
      const done &#x3D; (value) &#x3D;&gt; resolve(value);
      const abort &#x3D; () &#x3D;&gt; {
        reject(new Error(&#x27;The transaction was manually aborted&#x27;));
        txn.abort();
      };
      txn.onerror &#x3D; (evt) &#x3D;&gt; reject(evt.target.error);
      txn.onabort &#x3D; (evt) &#x3D;&gt; reject(evt.target.error);
      txn.oncomplete &#x3D; () &#x3D;&gt; resolve();

      const stores &#x3D; {};
      for (const storeName of storeNames) {
        stores[storeName] &#x3D; txn.objectStore(storeName);
      }
      callback(stores, done, abort);
    });
    return result;
  }

  /**
   * Delegates async to a native IDBObjectStore method.
   *
   * @param {string} method The method name.
   * @param {string} storeName The object store name.
   * @param {string} type Can be &#x60;readonly&#x60; or &#x60;readwrite&#x60;.
   * @param {...*} args The list of args to pass to the native method.
   * @return {*} The result of the transaction.
   */
  async _call(method, storeName, type, ...args) {
    await this.open();
    const callback &#x3D; (stores, done) &#x3D;&gt; {
      stores[storeName][method](...args).onsuccess &#x3D; (evt) &#x3D;&gt; {
        done(evt.target.result);
      };
    };

    return await this.transaction([storeName], type, callback);
  }

  /**
   * The default onversionchange handler, which closes the database so other
   * connections can open without being blocked.
   *
   * @param {Event} evt
   */
  _onversionchange(evt) {
    this.close();
  }

  /**
   * Closes the connection opened by &#x60;DBWrapper.open()&#x60;. Generally this method
   * doesn&#x27;t need to be called since:
   *   1. It&#x27;s usually better to keep a connection open since opening
   *      a new connection is somewhat slow.
   *   2. Connections are automatically closed when the reference is
   *      garbage collected.
   * The primary use case for needing to close a connection is when another
   * reference (typically in another tab) needs to upgrade it and would be
   * blocked by the current, open connection.
   */
  close() {
    if (this._db) this._db.close();
  }
}

// Exposed to let users modify the default timeout on a per-instance
// or global basis.
DBWrapper.prototype.OPEN_TIMEOUT &#x3D; 2000;

export default DBWrapper;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>